## 如果真想玩转C语言，就需要理解C语言如何操纵存储器

C语言在如何使用存储器方面赋予了你更多的掌控权。在本章中，你将揭开存储器神秘的面纱，看到读写变量时到底发生了什么；学习数组的工作原理，以及怎样避免烦人的存储器错误；最重要的是，你将看到掌握指针和存储器寻址对成为一名地道的C程序员来讲有多么重要。

### 1、C代码包含*指针*

指针是理解C语言最基本的要素之一。那么什么是指针？指针就是存储器中某条数据的地址。
```
C语言中使用指针的原因:
    1. 在函数调用时，可以只传递一个指针，而不用传递整份数据。
    2. 让两段代码处理同一条数据，而不是处理两份独立的副本。
```
指针做了两件事：避免副本和共享数据。但既然指针只是地址而已，为什么它会令很多人感到困惑呢？因为指针是一种间接形式的地址。在茫茫储存器中追逐指针，一不小心就会迷路。而学习C指针的诀窍就是慢慢来。

### 2、深入挖掘存储器

为了理解什么是指针，需要切开计算机的存储器。 每当声明一个变量，计算机都会在存储器中某个地方为它创建空间。 如果在函数（例如main()函数）中声明变量，计算机会把它保存在栈（Stack）的存储器区段中；如果你在函数以外的地方声明变量，计算机则会把它保存在存储器的全局量段（Globals）。

```
int y = 1; /* 变量y位于全局变量段。存储器地址1 000 000。值为1 */
int main() {
    int x = 4; /* 变量x位于栈中。存储器地址4 100 000。值为4 */
    return 0;
}
+-------------------------------------------+
+           x[4]                    栈      +
+-------------------------------------------+
+                                   堆      +
+-------------------------------------------+
+           y[1]                    全局量   +
+-------------------------------------------+
+                                   常量段   +
+-------------------------------------------+
+                                   代码段   +
+-------------------------------------------+
```
+ 栈
```
    这是存储器用来保存*局部变量*的部分。每当调用函数，函数的所有局部变量都在栈上创建。它之所以叫栈是因为它看起来就像堆积而成的栈板；
    当进入函数时，把变量从栈顶拿走。奇怪的是，栈做起事来颠三倒四，它从存储器的顶部开始，向下增长。
```
+ 堆

+ 全局量
+ 常量
+ 代码

如果想要找到变量的存储器地址，可以用&运算符：

```
printf("x保存在 %p\n", &x);
    x保存在 0x3E8FA0  --->你的电脑可能得到不同的值
              ^----------这是4 100 000十六进制的表示

为什么局部变量保存在栈里，而全局变量保存在其它地方？
    局部变量和全局变量的用法不同。你永远只能得到一份全局变量，但如果写来一个调用自己的函数，就会得到同一个局部变量的很多个实例。

存储器中的其它区域是用来做什么的？
    你会在后序章节中看到它们的作用。
```

### 3、使用存储器指针

1. 得到变量的地址

```
用&运算符找到变量保存在存储器中的位置，你已经知道了：
            
            int x = 4;
            printf("x lives at %p\n", &x);

一旦得到了变量的地址，就需要把它保存在某个地方。为此需要指针变量。指针变量是一个用来保存存储器地址的变量。
            
            int *address_of_x = &x;
```

2. 读取地址的内容

```
当你有了存储器地址，就想读取保存在那里的数据，这是可以用*运算符：

            int value_stored = *address_of_x;

*运算符和&运算符恰好相反。&运算符接受一个数据，然后告诉你这个数据保存在哪里；*运算符接收一个地址，然后告诉你这个地址中保存的是什么数据。
因此指针有时也叫引用，所以*运算符也可以描述成对指针进行解引用。
```

3. 改变地址的内容

```
如果你有一个指针变量，并想修改这个变量指向地址中的数据，可以再次使用*运算符，只不过这次需要把指针变量放在赋值运算符左边。

            *address_of_x = 99;
```

```
指针是真实的地址单元，还是某种形式的引用？
    它们是进程存储器中真实编号的地址。

为什么存储器是进程的？
    计算机会为每个进程分配一个简版存储器，看起来就像是一长串字节。

但存储器并非如此？
    实际但存储器复杂多了，但细节对进程隐藏了起来，这样操作系统就可以在存储器中移动进程，或释放并重新加载到其它位置。

存储器不仅仅是一长列字节？
    物理存储器的结构十分复杂，计算机通常会将存储器地址分组映射到存储芯片的不同的存储体（memorybank）。

我需要理解它是怎么映射的吗？
    对大部分程序来说，你不需要关心机器组织存储器的细节。

为什么我一定要用%p格式串来打印指针？
    不一定要用%p，在大多数的现代计算机可以用%li，但编译器可能会给出一条警告。

为什么%p以十六进制显示存储器地址？
    工程师通常以十六进制表示存储器地址。

如果我们把读取存储器单元的内容称为“解引用”，那么指针是不是应该叫“引用”？
    人们有时会把指针叫做“引用”，因为它引用存储器中的某个地址单元。但C++程序员通常用“引用”表示C++中一个稍有不同的概念。
```
### 4、 怎么把字符串传给函数？

```
void fortune_cookie(char msg[]) {
   printf("Message reads: %s\n", msg); 
}

char quote[] = "Cooies make you fat";
fortune_cookie(quote);
```
你把参数msg定义为数组，但是因为不知道字符串有多长，所以msg没有长度。这似乎很简单，但是奇怪的事情发生来。。。

C语言中有一个叫sizeof的运算符，它能告知某样东西在存储器中占多少字节，既可以对数组类型使用，也可以对某条数据使用。
```
sizeof(int);            ---> 在大多数计算机中，将返回4。
sizeof("Turtles!");     ---> 将返回9，其中包括8个字符外加\0哨兵。
```
当你在上面fortune_cookie里加入检查传入字符串长度时，离奇的事情发生了
```
void fortune_cookie(char msg[]) {
   printf("Message reads: %s\n", msg); 
   printf("msg occupies %i bytes\n", siezof(msg)); /* 为什么是8，在一些计算机甚至是4。*/ 
}

char quote[] = "Cooies make you fat";
fortune_cookie(quote);

数组变量好比指针。。。
当你创建了数组，数组变量就可以当作指针使用，它指向数组在存储器的起始位置。当C语言在函数中看到这样一行代码时
        
        char quote[] = "Cooies make you fat";

计算机会为字符串的每一个字符以及结束字符\0在栈上分配空间，并把首字母的地址和quote变量关联起来，代码中只要出现了quote这个变量，计算机就会把它替换成字符串首字符的地址。
```

+ 指针退化

```
数组变量和指针变量有一点小小的区别，所以把数组赋值给指针的时候千万要小心。
假如把数组赋值给指针变量，指针变量只会包含数组的地址信息，而对数组的长度一无所知，相当于丢失了一些信息。
我们把这种信息的丢失称为退化。

只要把数组传递给函数，数组免不了退化为指针，但需要记清楚代码中哪些地方发生过数组退化，
因为它们会引发一些不易觉察的错误。
```
### 5、 为什么指针有类型

因为指针运算会暗度陈仓。如果对char指针加1，指针会指向存储器中下一个地址，那是因为char就占1字节。
如果是int指针呢？int通常占4字节，如果对int指针加1，编译后的代码就会对存储器地址加4。
